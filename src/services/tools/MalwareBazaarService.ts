import { BaseToolService, ToolServiceConfig } from '../base/BaseToolService';
import { DetectedIOC, IOCAnalysisResult, IOCType } from '@/types/ioc';
import {
  MalwareBazaarQueryResponse,
  MalwareBazaarAnalysisStats,
  DELIVERY_METHOD_LABELS,
  MALWARE_TAG_CATEGORIES,
} from '@/types/malwarebazaar';

/**
 * MalwareBazaar Service
 * Integrates with MalwareBazaar API for malware hash analysis
 * Documentation: https://bazaar.abuse.ch/api/
 *
 * API Details:
 * - Supports MD5, SHA1, and SHA256 hash queries
 * - Provides malware sample information including file signatures, delivery methods, and threat intelligence
 * - Requires API key authentication
 */
export class MalwareBazaarService extends BaseToolService {
  private readonly baseURL = 'https://mb-api.abuse.ch/api/v1/';

  constructor(config: ToolServiceConfig) {
    super(config);
  }

  get name(): string {
    return 'MalwareBazaar';
  }

  get supportedIOCTypes(): IOCType[] {
    // MalwareBazaar only supports hash-based queries
    return [IOCType.MD5, IOCType.SHA1, IOCType.SHA256];
  }

  /**
   * Analyze an IOC using MalwareBazaar
   */
  async analyze(ioc: DetectedIOC): Promise<IOCAnalysisResult> {
    if (!this.isConfigured()) {
      return this.createErrorResult(ioc, 'MalwareBazaar API key not configured');
    }

    if (!this.supports(ioc.type)) {
      return this.createUnsupportedResult(ioc);
    }

    try {
      return await this.queryHash(ioc);
    } catch (error) {
      return this.createErrorResult(
        ioc,
        error instanceof Error ? error : 'Unknown error occurred'
      );
    }
  }

  /**
   * Query hash information
   * Endpoint: POST /
   * @param ioc - Hash to query (MD5, SHA1, or SHA256)
   */
  private async queryHash(ioc: DetectedIOC): Promise<IOCAnalysisResult> {
    const endpoint = this.baseURL;

    // Prepare form data
    const formData = new FormData();
    formData.append('query', 'get_info');
    formData.append('hash', ioc.value);

    const response = await this.fetchWithTimeout(endpoint, {
      method: 'POST',
      headers: {
        'Auth-Key': this.config.apiKey!,
      },
      body: formData,
    });

    // Handle rate limiting
    if (response.status === 429) {
      const retryAfter = response.headers.get('Retry-After');
      throw new Error(
        `Rate limit exceeded. ${retryAfter ? `Try again after ${retryAfter} seconds.` : 'Please try again later.'}`
      );
    }

    if (!response.ok) {
      throw new Error(`MalwareBazaar API error: ${response.statusText} (${response.status})`);
    }

    const data: MalwareBazaarQueryResponse = await response.json();

    // Handle different query statuses
    if (data.query_status === 'invalid_api_key') {
      throw new Error('Invalid API key. Please check your MalwareBazaar API key.');
    }

    if (data.query_status === 'illegal_hash') {
      throw new Error('Invalid hash format. Please provide a valid MD5, SHA1, or SHA256 hash.');
    }

    if (data.query_status === 'no_results') {
      // No malware found for this hash - this is actually good news
      return {
        ioc,
        source: this.name,
        status: 'safe',
        details: {
          found: false,
          message: 'No malware samples found for this hash in MalwareBazaar database',
        },
        timestamp: Date.now(),
      };
    }

    // Calculate statistics
    const stats = this.calculateStats(data);

    // Determine threat status
    const status = this.determineStatusFromResults(data);

    return {
      ioc,
      source: this.name,
      status,
      details: {
        // Core metrics
        found: true,
        totalSamples: stats.totalSamples,
        uniqueSignatures: stats.uniqueSignatures,
        fileTypes: stats.fileTypes,
        tags: stats.tags,

        // Temporal information
        firstSeen: stats.firstSeen,
        lastSeen: stats.lastSeen,

        // Intelligence metrics
        hasCodeSigning: stats.hasCodeSigning,
        totalDownloads: stats.totalDownloads,
        totalUploads: stats.totalUploads,

        // Sample details (limited to 5 for display)
        samples: data.data?.slice(0, 5).map(sample => ({
          sha256: sample.sha256_hash,
          sha1: sample.sha1_hash,
          md5: sample.md5_hash,
          fileName: sample.file_name,
          fileSize: sample.file_size,
          fileType: sample.file_type,
          fileMime: sample.file_type_mime,
          signature: sample.signature,
          firstSeen: sample.first_seen,
          lastSeen: sample.last_seen,
          reporter: sample.reporter,
          originCountry: sample.origin_country,
          deliveryMethod: sample.delivery_method,
          deliveryMethodLabel: sample.delivery_method
            ? DELIVERY_METHOD_LABELS[sample.delivery_method] || sample.delivery_method
            : 'Unknown',
          tags: sample.tags || [],
          tagLabels: (sample.tags || []).map(
            tag => MALWARE_TAG_CATEGORIES[tag.toLowerCase()] || tag
          ),
          comment: sample.comment,
          intelligence: sample.intelligence,
          codeSign: sample.code_sign,
        })),
      },
      timestamp: Date.now(),
    };
  }

  /**
   * Calculate statistics from MalwareBazaar response
   */
  private calculateStats(data: MalwareBazaarQueryResponse): MalwareBazaarAnalysisStats {
    const samples = data.data || [];

    // Extract unique signatures
    const uniqueSignatures = new Set<string>();
    const fileTypes = new Set<string>();
    const tags = new Set<string>();
    let totalDownloads = 0;
    let totalUploads = 0;
    let hasCodeSigning = false;
    let firstSeen: string | undefined;
    let lastSeen: string | undefined;

    samples.forEach(sample => {
      if (sample.signature) {
        uniqueSignatures.add(sample.signature);
      }
      if (sample.file_type) {
        fileTypes.add(sample.file_type);
      }
      if (sample.tags) {
        sample.tags.forEach(tag => tags.add(tag));
      }
      if (sample.intelligence) {
        totalDownloads += sample.intelligence.downloads || 0;
        totalUploads += sample.intelligence.uploads || 0;
      }
      if (sample.code_sign && sample.code_sign.length > 0) {
        hasCodeSigning = true;
      }

      // Track first and last seen dates
      if (!firstSeen || sample.first_seen < firstSeen) {
        firstSeen = sample.first_seen;
      }
      if (!lastSeen || sample.last_seen > lastSeen) {
        lastSeen = sample.last_seen;
      }
    });

    return {
      totalSamples: samples.length,
      uniqueSignatures: Array.from(uniqueSignatures),
      fileTypes: Array.from(fileTypes),
      tags: Array.from(tags),
      firstSeen,
      lastSeen,
      hasCodeSigning,
      totalDownloads,
      totalUploads,
    };
  }

  /**
   * Determine threat status based on MalwareBazaar results
   *
   * Status Interpretation:
   * - Found in database = Malicious (known malware)
   * - Not found = Safe (unknown hash)
   */
  private determineStatusFromResults(
    data: MalwareBazaarQueryResponse
  ): 'safe' | 'suspicious' | 'malicious' | 'unknown' {
    // If found in MalwareBazaar database, it's malicious
    if (data.query_status === 'ok' && data.data && data.data.length > 0) {
      return 'malicious';
    }

    // Not found means it's safe (not known malware)
    if (data.query_status === 'no_results') {
      return 'safe';
    }

    return 'unknown';
  }

  /**
   * Batch analyze is not optimized for MalwareBazaar (no bulk endpoint)
   * Falls back to sequential processing
   */
  async analyzeBatch(iocs: DetectedIOC[]): Promise<IOCAnalysisResult[]> {
    // Use default sequential implementation from BaseToolService
    return super.analyzeBatch(iocs);
  }
}
